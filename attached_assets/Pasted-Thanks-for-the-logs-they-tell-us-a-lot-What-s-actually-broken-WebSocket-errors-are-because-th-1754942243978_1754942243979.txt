Thanks for the logs — they tell us a lot.

What’s actually broken
	•	WebSocket errors are because the web app is trying to open ws(s)://<front‑end origin>/api/mcp/ws (port 5173) while the WS server lives on the API port (3000). So the browser is upgrading the connection against Vite instead of the API → instant error.
	•	The KML resolver is fine (status: 200). Your PARLAY pipeline is working (modulo auth/tiles).
	•	The DOMException {} during Vite “connecting…” is the same root issue (bad WS target) and/or an https/wss mismatch.
	•	The “unknown property data‑replit‑metadata” lines are harmless (just Replit DOM markers).

Quick fixes (copy‑paste patches)

1) Frontend: point WS to the API host/port + handle http→ws / https→wss

Edit apps/web/src/lib/mcpClient.js:

import axios from "axios";

const KEY = import.meta.env.VITE_MCP_KEY || "";
const API_BASE =
  import.meta.env.VITE_API_BASE ||
  (location.origin.includes(":5173")
    ? location.origin.replace(":5173", ":3000")
    : location.origin); // dev: 5173→3000 ; prod: same origin

export async function mcpRun(name, payload){
  const { data } = await axios.post(`${API_BASE}/api/mcp/run`, { name, payload }, {
    headers: KEY ? { "x-mcp-key": KEY } : {}
  });
  return data;
}

export function mcpConnect(onMessage){
  const apiUrl = new URL(API_BASE);
  const wsProto = apiUrl.protocol === "https:" ? "wss:" : "ws:";
  const wsUrl = `${wsProto}//${apiUrl.host}/api/mcp/ws`;
  const ws = new WebSocket(wsUrl);
  ws.onmessage = (msg)=> onMessage?.(JSON.parse(msg.data));
  return ws;
}

If you deploy behind a different API origin, set VITE_API_BASE=https://your-api-host in web env.

2) API: make sure the WS upgrade is actually attached to the HTTP server

Double‑check apps/api/src/index.js. It must look like this (key parts shown):

import express from "express";
import cors from "cors";
import http from "http";
import cookieParser from "cookie-parser";
import { migrate } from "./db.js";

// ... your route imports ...
import { attachWs } from "./mcp/ws.js";

await migrate();
const app = express();
app.use(cors({ origin: process.env.ALLOWED_ORIGIN?.split(",") || true, credentials: true }));
app.use(express.json({ limit: "15mb" }));
app.use(cookieParser());

// routes...
app.use("/api", publicApi);
app.use("/api", compsApi);
app.use("/api", agentApi);
app.use("/api", scrapeApi);
app.use("/api", msApi);
app.use("/api", toolsApi);
app.use("/api", ingestApi);
app.use("/api", pipelineApi);
app.use("/api", mcpApi);
app.use("/public", express.static("public"));

const port = process.env.PORT || 3000;
const server = http.createServer(app);
attachWs(server);              // <-- IMPORTANT: attach the WS upgrade handler
server.listen(port, ()=> console.log("API+WS on :"+port));

And apps/api/src/mcp/ws.js should not start its own server — only attach to the one above:

import { WebSocketServer } from "ws";
import { bus } from "./core.js";

export function attachWs(server){
  const wss = new WebSocketServer({ noServer: true });

  server.on("upgrade", (req, socket, head) => {
    if (!req.url.startsWith("/api/mcp/ws")) return;
    wss.handleUpgrade(req, socket, head, (ws) => {
      ws.send(JSON.stringify({ type:"welcome", ts: Date.now() }));
      const onStart = (e)=> ws.readyState===1 && ws.send(JSON.stringify({ type:"job.start", ...e }));
      const onDone  = (e)=> ws.readyState===1 && ws.send(JSON.stringify({ type:"job.done",  ...e }));
      const onErr   = (e)=> ws.readyState===1 && ws.send(JSON.stringify({ type:"job.error", ...e }));
      const onEvt   = (e)=> ws.readyState===1 && ws.send(JSON.stringify({ type:"event",     ...e }));
      bus.on("job.start", onStart);
      bus.on("job.done", onDone);
      bus.on("job.error", onErr);
      bus.on("event", onEvt);
      ws.on("close", ()=>{
        bus.off("job.start", onStart);
        bus.off("job.done", onDone);
        bus.off("job.error", onErr);
        bus.off("event", onEvt);
      });
    });
  });
}

3) CORS + ALLOWED_ORIGIN

In apps/api/.env:

ALLOWED_ORIGIN=http://localhost:5173

If you’re on Replit preview (https), add it too, comma‑separated:

ALLOWED_ORIGIN=http://localhost:5173,https://<your-repl-subdomain>.repl.co

4) Vite HMR DOMException still showing?

That’s typically Vite trying (and failing) to WS the dev server when the tab was backgrounded or throttled. It won’t affect your app once the MCP WS points to the API port. You can ignore it, or restart the Vite dev server after making the mcpClient.js change.

⸻

Sanity checks to run (copy/paste)

# API side
curl -s http://localhost:3000/api/mcp/ping
# -> {"ok":true}

# From browser console after reload
new WebSocket((location.origin.replace('http','ws').replace(':5173',':3000')) + '/api/mcp/ws')
# -> should connect and receive a welcome message

# Tools Console (UI) should now stream events when you run any tool


⸻

Why you can’t “install Google Earth Pro” in the environment

It’s a desktop GUI app, not embeddable nor licensed for server embedding. The right way is exactly what you’re doing: server‑side KML NetworkLink resolution + view‑based tile fetching + (optionally) Google Earth UA spoof and auth key in server env.

⸻

If you want, send me the two files and I’ll diff them against the snippets above; I’ll point out exact lines to change. Once WS is fixed, your Tools Console will light up and those WebSocket errors will stop.