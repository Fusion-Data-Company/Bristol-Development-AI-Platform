Thanks — that report tells me exactly why the widget isn’t “working” and why your app is going down over and over.

Here’s the breakdown:

⸻

1. The widget isn’t the direct cause of the port failure

The root crash is:

Server process terminates or fails to bind to port 5000

From the report:
	•	The server logs “serving on port 5000” but then drops before Vite can connect.
	•	This happens before any front-end component (like the widget) can even render.
	•	That’s why /api/openrouter calls fail with 401 and nothing from the dropdown will respond — the backend is gone.

⸻

2. Why this is happening in your current stack

Your setup is:
	•	Custom Express + Vite (React front end)
	•	Running on Replit dev server (Replit expects the process to open a port in ~60s)
	•	Extra layers:
	•	DB connection (via Drizzle + Neon)
	•	“MCP tools” initialization
	•	Route registration including OpenRouter
	•	Vite HMR client tries to open a WebSocket to localhost:undefined after backend dies → gives you that DOMException in the console.

If any startup step hangs (e.g. DB, MCP) or throws without try/catch, Replit kills the process → Vite client loses connection → widget never has a backend.

⸻

3. Most probable sequence
	1.	You merged the widget into App.tsx.
	2.	On refresh, Vite dev server starts, Express server starts.
	3.	Express runs all startup code (DB connect, MCP init, route wiring).
	4.	One of those async inits never resolves or rejects → no app.listen() → Replit times out after 60s.
	5.	The front end reloads but can’t talk to backend → HMR tries to reconnect with invalid localhost:undefined → DOMException.

⸻

4. How to get stable again

We can isolate the problem in <15 minutes:

Step 1 — Minimal server boot

Temporarily comment out:
	•	DB connect code
	•	MCP initialization
	•	Anything not app.use(express.json()) + app.listen(PORT)

Example:

import express from "express";
const app = express();

app.get("/health", (req, res) => res.json({ ok: true }));

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Listening on ${PORT}`));

Run npm run dev.
If this stays up → your base server is fine → re-enable features one at a time.

⸻

Step 2 — Wrap slow inits

For DB + MCP:

try {
  await initDB({ timeoutMs: 5000 });
} catch (err) {
  console.error("DB init failed:", err);
  // Continue without DB to keep app alive
}

If DB is slow/unreachable, you want a non-blocking startup and a health endpoint that says “DB: down” rather than crashing.

⸻

Step 3 — Fix Vite HMR WS

In vite.config.ts:

server: {
  https: true,
  hmr: {
    protocol: 'wss',
    host: process.env.HMR_HOST || '<your-replit-hostname>',
    clientPort: 443,
  },
}

This stops localhost:undefined errors even if the backend drops.

⸻

Step 4 — Test widget once backend stable

Once /health works and server stays up:
	•	Ensure /api/openrouter returns 200 (even if mocked).
	•	Widget dropdown will still populate from /api/openrouter-models (yours is correct).
	•	Sending a message should hit /api/openrouter, which now responds.

⸻

5. Why the widget appeared to break it

When you added it:
	•	You started making /api/openrouter calls in dev → required OPENROUTER_API_KEY and your auth middleware to pass.
	•	But the real killer is the port timeout — the widget just exposed the fact that your server’s startup path is brittle.

⸻

Do you want me to give you a drop-in “safe startup” version of server/index.ts that:
	•	Logs each init step,
	•	Times out DB/MCP connects,
	•	Keeps server alive with degraded mode if something fails,
	•	And makes /api/openrouter and /api/openrouter-models usable immediately?

That would get the app running so we can troubleshoot the widget’s actual chat calls without Replit killing your process.